# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rjdOU0inPUx1D8PE1LSKDqHSR2N_0Lfm
"""

!pip install torchvision
import torch as t
import torchvision as tv
import torchvision.transforms as transforms
from torchvision.transforms import ToPILImage
show = ToPILImage() # 可以把Tensor转成Image，方便可视化

# 第一次运行程序torchvision会自动下载CIFAR-10数据集，
# 大约100M，需花费一定的时间，
# 如果已经下载有CIFAR-10，可通过root参数指定

# 定义对数据的预处理
transform = transforms.Compose([
        transforms.ToTensor(), # 转为Tensor
        transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)), # 归一化
                             ])

# 训练集
trainset = tv.datasets.CIFAR10(
                    root='/Users/captain/Downloads/cifar-10-batches-py',
                    train=True, 
                    download=True,
                    transform=transform)

trainloader = t.utils.data.DataLoader(
                    trainset, 
                    batch_size=4,
                    shuffle=True, 
                    num_workers=2)

# 测试集
testset = tv.datasets.CIFAR10(
                    '/Users/captain/Downloads/cifar-10-batches-py',
                    train=False, 
                    download=True, 
                    transform=transform)

testloader = t.utils.data.DataLoader(
                    testset,
                    batch_size=4, 
                    shuffle=False,
                    num_workers=2)

classes = ('plane', 'car', 'bird', 'cat',
           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')

(data, label) = trainset[100]
print(classes[label])
show((data + 1) / 2).resize((100, 100))

import torch
from torch.utils.data import DataLoader
import torchvision.datasets as data
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn import decomposition
# 颜色设置
color = ['yellow','black','aqua','green','teal','orange','navy','pink','purple','red']
# 绘图
def show(v2,y):
    for i in range(len(v2)):
        plt.scatter(v2[i][0],v2[i][1],color=color[y[i]])
    plt.show()
def show3d(v3,y):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    for i in range(len(v3)):
        ax.scatter(v3[i][0],v3[i][1],v3[i][2],color=color[y[i]])
    plt.show()
 
trans = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(mean=0, std=1)
])

loader_train = DataLoader(trainset, batch_size=1000, shuffle=True)

#5种 manifold learning可供选择， 其中lle又分为4种
#函数参数：维度，原始图片矩阵 
#所调用到的函数，除维度以外，其余参数已设为默认值或推荐/适中值

from sklearn.manifold import (
    Isomap as iso,
    LocallyLinearEmbedding as lle,
    MDS,
    SpectralEmbedding as se,
)
from sklearn.random_projection import SparseRandomProjection as rd

def lleStandard(dim, data):
  output = lle(n_neighbors=30, n_components=dim, method='standard').fit_transform(data)
  return output

def lleModified(dim, data):
  output = lle(n_neighbors=30, n_components=dim, method='modified').fit_transform(data)
  return output

def lleHessian(dim, data):
  output = lle(n_neighbors=30, n_components=dim, method='hessian').fit_transform(data)
  return output

def lleLTSA(dim, data):
  output = lle(n_neighbors=30, n_components=dim, method='ltsa').fit_transform(data)
  return output

def isomap(dim, data):
  output = iso(n_neighbors=30, n_components=dim).fit_transform(data)
  return output

def mds(dim, data):
  output = MDS(n_components=dim, n_init=1, max_iter=120, n_jobs=dim).fit_transform(data)
  return output

def spEmb(dim, data):
  output = se(n_components=dim,random_state=0, eigen_solver='arpack').fit_transform(data)
  return output

def random(dim, data):
  output = rd(n_components=dim,random_state=40).fit_transform(data)
  return output

i = 0
for (x,y) in loader_train:
    x = x.flatten(start_dim=1,end_dim=-1)
    x = torch.squeeze(x)

    vector = []

    #available Manifold Learning methods to reduce dimension
    reduced = lleStandard(50, x)
    #reduced = lleModified(3, x)
    #reduced = lleHessian(3, x)
    #reduced = lleLTSA(3, x)
    #reduced = isomap(3, x)
    #reduced = mds(3, x)
    #reduced = spEmb(3, x)
    #reduced = random(3, x)

    vector.append(reduced)

    #only reduce the first pic as an example
    if i > 0:
        break;
    i=i+1

print('reduced picture No.', i - 1)
show3d(vector[0],y)